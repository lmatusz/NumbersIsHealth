// generated by Fast Light User Interface Designer (fluid) version 1.0305

#include <fstream>
#include "LottoGUI.h"

using boost::asio::ip::tcp;

enum { max_length = 1024*1024 };

class ssl_client
{
public:
    ssl_client(boost::asio::io_context& io_context,
           boost::asio::ssl::context& context,
           boost::asio::ip::tcp::resolver::results_type endpoints, std::string request)
            : socket_(io_context, context)
    {
        request_ = request;
        socket_.set_verify_mode(boost::asio::ssl::verify_none);
        socket_.set_verify_callback(
                boost::bind(&ssl_client::verify_certificate, this,
                            boost::placeholders::_1, boost::placeholders::_2));

        boost::asio::async_connect(socket_.lowest_layer(), endpoints,
                                   boost::bind(&ssl_client::handle_connect, this,
                                               boost::asio::placeholders::error));
    }

    bool verify_certificate(bool preverified,
                            boost::asio::ssl::verify_context& ctx)
    {
        // The verify callback can be used to check whether the certificate that is
        // being presented is valid for the peer. For example, RFC 2818 describes
        // the steps involved in doing this for HTTPS. Consult the OpenSSL
        // documentation for more details. Note that the callback is called once
        // for each certificate in the certificate chain, starting from the root
        // certificate authority.

        // In this example we will simply print the certificate's subject name.
        char subject_name[256];
        X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());
        X509_NAME_oneline(X509_get_subject_name(cert), subject_name, 256);
        std::cout << "Verifying " << subject_name << "\n";

        return preverified;
    }

    void handle_connect(const boost::system::error_code& error)
    {
        if (!error)
        {
            socket_.async_handshake(boost::asio::ssl::stream_base::client,
                                    boost::bind(&ssl_client::handle_handshake, this,
                                                boost::asio::placeholders::error));
        }
        else
        {
            std::cout << "Connect failed: " << error.message() << "\n";
        }
    }

    void handle_handshake(const boost::system::error_code& error)
    {
        if (!error)
        {
            size_t request_length = strlen(request_.c_str());

            boost::asio::async_write(socket_,
                                     boost::asio::buffer(request_.c_str(), request_length),
                                     boost::bind(&ssl_client::handle_write, this,
                                                 boost::asio::placeholders::error,
                                                 boost::asio::placeholders::bytes_transferred));
        }
        else
        {
            std::cout << "Handshake failed: " << error.message() << "\n";
        }
    }

    void handle_write(const boost::system::error_code& error,
                      size_t bytes_transferred)
    {
        if (!error)
        {
            boost::asio::async_read_until(socket_,
                                    boost::asio::dynamic_buffer(reply_str), "</body>",
                                    boost::bind(&ssl_client::handle_read, this,
                                                boost::asio::placeholders::error,
                                                boost::asio::placeholders::bytes_transferred));

        }
        else
        {
            std::cout << "Write failed: " << error.message() << "\n";
        }
    }

    void handle_read(const boost::system::error_code& error,
                     size_t bytes_transferred)
    {
        if (!error)
        {
            std::cout << "Reply: ";
            std::cout.write(reply_str.c_str(), bytes_transferred);
            std::cout << "\n";
        }
        else
        {
            std::cout << "Read failed: " << error.message() << "\n";
        }
    }

private:
    boost::asio::ssl::stream<boost::asio::ip::tcp::socket> socket_;
    std::string request_;
    std::string reply_str;
};

class NumbersTable : public Fl_Table
{
    int values[11][5];
public:
    NumbersTable(int x, int y, int w, int h, const char *l) : Fl_Table(x, y, w, h, l)
    {
        this->rows(11);
        this->cols(5);
    }
    ~NumbersTable() { }

protected:
    enum Numbers_HTTP_Count {
        TWENTY = 20,
        TWO_HUNDRED = 200,
        FIVE_HUNDRED = 500
    };

    std::vector<short> getNumbersHTTP(Numbers_HTTP_Count count)
    {
        std::vector<short> vector_of_numbers;

        try
        {
            boost::asio::io_context io_context;

            // Get a list of endpoints corresponding to the server name.
            tcp::resolver resolver(io_context);
            std::string host = "www.wynikilotto.net.pl";
            tcp::resolver::results_type endpoints = resolver.resolve(host, "https");

            boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23_client);

            std::string request_stream;
            request_stream.append("GET /mini-lotto/wyniki/ HTTP/1.0\r\n");
            //request_stream.append("Content-Type: application/x-www-form-urlencoded\r\n");
            request_stream.append("Host: " + host + "\r\n");
            request_stream.append("User-Agent: Mozilla\r\n");
            request_stream.append("Accept: */*\r\n");
            request_stream.append("Connection: keep-alive\r\n");
            request_stream.append("\r\n\r\n");
//            switch (count)
//            {
//                case FIVE_HUNDRED:
//                    request_stream.append("ile=500&order=0");
//                    break;
//                case TWO_HUNDRED:
//                    request_stream.append("ile=200&order=0");
//                    break;
//                case TWENTY:
//                    request_stream.append("ile=20&order=0");
//                    break;
//            }

            ssl_client _client(io_context, ctx, endpoints, request_stream);

            io_context.run();
        }
        catch (std::exception& e)
        {
            std::cout << "Exception: " << e.what() << "\n";
        }
        return vector_of_numbers;
    }

    void draw_cell(TableContext context, int R=0,int C=0,int X=0,int Y=0, int W=0,int H=0) {
        switch (context)
        {
            case Fl_Table::CONTEXT_CELL:
                fl_draw_box(FL_THIN_UP_BOX, X,Y,W,H, FL_GRAY);
                fl_push_clip(X+3, Y+3, W-6, H-6);
                fl_color(FL_GREEN);
                fl_font(FL_COURIER, 12);
                if (0 == R)
                {
                    getNumbersHTTP(Numbers_HTTP_Count::FIVE_HUNDRED);
                    switch(C)
                    {
                        case 0:
                            fl_draw("12", X+3, Y+3, W-6, H-6, FL_ALIGN_CENTER);
                            break;
                        case 1:
                            fl_draw("13", X+3, Y+3, W-6, H-6, FL_ALIGN_CENTER);
                            break;
                        case 2:
                            fl_draw("14", X+3, Y+3, W-6, H-6, FL_ALIGN_CENTER);
                            break;
                        case 3:
                            fl_draw("15", X+3, Y+3, W-6, H-6, FL_ALIGN_CENTER);
                            break;
                        case 4:
                            fl_draw("22", X+3, Y+3, W-6, H-6, FL_ALIGN_CENTER);
                            break;
                    }
                }
                fl_pop_clip();
                break;
        }
        return;
    }
};


int main()
{
    auto* window = new Fl_Double_Window(900, 600);
    auto* table = new NumbersTable(25, 25, 850, 550, "Liczby MiniLotto");

    window->end();
    window->resizable(table);
    window->show();
    return(Fl::run());
}